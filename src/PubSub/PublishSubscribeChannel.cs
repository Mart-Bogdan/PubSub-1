namespace Phantom.PubSub
{
using System;
    using System.Collections.Concurrent;
using System.Collections.Generic;
    using System.Diagnostics;
    using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
    using System.Timers;
using System.Transactions;
    using Phantom.PubSub;

    /// <summary>
    /// PublishSubscribeChannel will accepts new messages puts them on a queue and fire calls to all subscribers
    /// </summary>
    /// <typeparam name="T">The Type that you wish tp publish each type requires its own implementation</typeparam>
    public class PublishSubscribeChannel<T> : IPublishSubscribeChannel<T>, IDisposable
    {
        private static object queueLock = new object();

        private static bool processRunning = false;
                
        private IQueueProvider<T> queueProvider;

        private System.Timers.Timer timer;

        private Dictionary<string, Tuple<string, Type, TimeSpan>> subscriberInfos = new Dictionary<string, Tuple<string, Type, TimeSpan>>();
        
        public PublishSubscribeChannel()
        {
                }

        public PublishSubscribeChannel(IQueueProvider<T> queueProvider)
        {
            this.queueProvider = queueProvider;
        }

        ~PublishSubscribeChannel()
        {
            // Finalizer calls Dispose(false)
            this.Dispose(false);
            }

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Publishes a message first by placing on a durable Queue, then passing the message to a new thread for processing.
        /// Returns as soon as the message is succesfully on the Queue.
        /// This component does not read the message from the Que to start processing. It takes the same message that is added to the Queue and starts processing
        /// as soon as it is guaranteed to be on the queue.
        /// </summary>
        /// <param name="message">The message of the type specified to process</param>
        public void PublishMessage(T message)
        {
            if (!BatchProcessor<T>.IsConfigured)
            {
                BatchProcessor<T>.ConfigureWithPubSubChannel(this);
            }

            List<ISubscriberMetadata> metadatalist = new List<ISubscriberMetadata>();
            foreach (var item in this.subscriberInfos)
            {
                var subscribermetadata = new SubscriberMetadata()
                {
                    // Name = item.Key, I dont think I need the name only the start time and the time to wait till it expires
                    TimeToExpire = item.Value.Item3,
                    StartTime = DateTime.Now,
                };
                metadatalist.Add(subscribermetadata);
            }

            var messageForQueue = new MessagePacket<T>(message, metadatalist);

            string result = this.queueProvider.PutMessageInTransaction(messageForQueue);
            Task.Factory.StartNew(() => this.HandleMessageForFirstTime(messageForQueue, result));
        }

        /// <summary>
        /// Batch processing alternative, this is used as part of the clean up process for Messages that expire prior to being handled. 
        /// </summary>
        public void ProcessBatch()
        {
            var traceSwitch = new TraceSwitch("Phantom.PubSub", "Phantom Pubsub Traceswitch");
            Trace.WriteLineIf(traceSwitch.TraceInfo, "ProcessBatch Should fire every 10 seconds:" + DateTime.Now.ToString());
            this.queueProvider.ProcessQueueAsBatch(this.HandleMessageForBatchProcessing);
        }

        /// <summary>
        /// This method receives a single message and processes all of the subscribers for each individual message. The subscribers are processed in parallel
        /// to ensure that one long running process will not impact the others.
        /// When all subscribers have indicate they have completed a flag is set to indicate that this message has completed publishing, and it is removed 
        /// from the Queue
        /// This method uses the Parallel.ForEach method, so Visual Studio parallel debugging can be used.
        /// </summary>
        /// <param name="messagePacket">THe message being sent inside of the messagepacket wrapper</param>
        /// <param name="messageId">ID of message generated by the queuein mechanism</param>
        /// <returns>True on success</returns>
        public bool HandleMessageForFirstTime(MessagePacket<T> messagePacket, string messageId)
        {
            if (messagePacket == null) throw new ArgumentNullException("messagePacket");
            if (string.IsNullOrEmpty(messageId)) throw new ArgumentNullException("messagePacket");

            var subscribersForThisMessage = this.GetSubscriptions();
            foreach (var item in subscribersForThisMessage)
            {
                item.SubscribersForThisMessage = subscribersForThisMessage;
            }

            Parallel.ForEach<ISubscriber<T>>(
                subscribersForThisMessage, 
                (ISubscriber<T> subscriber) =>
            {
                string newSubscriptionId = " SubScriber: " + subscriber.Name + ":: MessageID: " + messageId + "::";
                subscriber.Id = newSubscriptionId;
                subscriber.MessageId = messageId;
                    //// wire up the events
                    subscriber.OnProcessStartedEventHandler += new OnProcessStartedEventHandler(Subscriber_OnProcessStartedEvent);
                    subscriber.OnProcessCompletedEventHandler += new OnProcessCompletedEventHandler(Subscriber_OnProcessCompletedEvent);
                    activeSubscriptions.AddActiveSubscription(subscriber);
                    subscriber.Run((T)messagePacket.Body);
            });
            return true;
        }

        public bool HandleMessageForBatchProcessing(MessagePacket<T> messagePacket, string messageId)
        {
            if (messagePacket == null) throw new ArgumentNullException("messagePacket");
            if (string.IsNullOrEmpty(messageId)) throw new ArgumentNullException("messagePacket");

            foreach (var item in messagePacket.SubscriberMetadataList)
            {
                string subscriptionId = " SubScriber: " + item.Name + ":: MessageID: " + messageId + "::";

                if (HasExpired(item))
                {
                    ISubscriber<T> existingSubscription = null;
                    bool matchExists = activeSubscriptions.TryGetValue(subscriptionId, out existingSubscription);
                    if (matchExists)
                    {
                        if (existingSubscription.CanProcess())
                        {
                            existingSubscription.Run(messagePacket.Body);
                    }
                }
                    else 
                    {
                        // this is an error condition messages should not exist in queuw without existing in the activeSubscriptions in memory list
                        // we could keep looking and maybe find some subscribers and not otheres but we will never know if they ran to completion of not.
                        // So we choose to redatart all subscribers remember that idempotency is a must of subscribers 
                        if (this.queueProvider.CheckItsStillInTheQueue(messageId))
                        {
                            this.HandleMessageForFirstTime(messagePacket, messageId);
        }
                }
            }
        }
        
                return true;
            }

        public Subscribers<T> GetSubscriptions()
        {
            if (this.subscriberInfos == null || this.subscriberInfos.Count == 0)
            {
                throw new InvalidOperationException("There are no subscribers set up for this channel");
            }

            var subscribers = new Subscribers<T>();
            foreach (var item in this.subscriberInfos)
            {
                ISubscriber<T> subscriber = (ISubscriber<T>)Activator.CreateInstance(item.Value.Item2);
                subscriber.Name = item.Value.Item1;
                subscriber.TimeToExpire = item.Value.Item3;
                subscriber.SubscribersForThisMessage = subscribers;
                subscribers.Add(subscriber);   
            }

            return subscribers;
        }

        /// <summary>
        /// This method is provide for the inheriting member to override and allow some pre-processing in the Process Started event
        /// </summary>
        /// <param name="currentSubscription">The currently being processed subscription</param>
        public virtual void ProcessStarted(ISubscriber<T> currentSubscription) 
        {
        }

        /// <summary>
        /// Handles all post processing. Sets the status of the Subscriber to complete. Sets the status of the subsciption to complete.
        /// Checks if all of the other subscribers for this specific message have both started and completed, if they have then the function will
        /// call the queue provider to remove the message from the queue.
        /// </summary>
        /// <param name="currentSubscriber">the subscriber currently being processed</param>
        public void ProcessCompleted(ISubscriber<T> currentSubscriber)
        {
            if (currentSubscriber == null) throw new ArgumentNullException("currentSubscriber");

            currentSubscriber.FinishedProcessing = true;

            if (currentSubscriber.SubscribersForThisMessage.IfAllSubscribersCompletedLockAndRemove(this.RemoveFromQueue))
            {
            }
        }

        public ISubscriberInfo<T> AddSubscriberType(Type type)
        {
            return new SubscriberInfo<T>(type, this);
        }

        public IPublishSubscribeChannel<T> AddSubscriberInfo(Tuple<string, Type, TimeSpan> tuple)
        {
            if (tuple == null) throw new ArgumentNullException("tuple");

            this.subscriberInfos.Add(tuple.Item1, tuple);
            return this;
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                this.timer.Dispose();
            }
        }

        private static bool HasExpired(ISubscriberMetadata subscriberMetaData)
        {
            var nextstart = subscriberMetaData.StartTime + subscriberMetaData.TimeToExpire;
            if (DateTime.Compare(DateTime.Now, nextstart) > 0)
            {
                return true;
            }
            return false;
        }

        private static void CheckProcessingStatus()
        {
            // look for subscribers that have not completed by ther expirery time
            activeSubscriptions.ExpireOldSubscriptions();
        }

        private void Subscriber_OnProcessCompletedEvent(object sender, ProcessCompletedEventArgs e)
        {
            this.ProcessCompleted(e.CurrentSubscription as ISubscriber<T>);
    }

       private void Subscriber_OnProcessStartedEvent(object sender, ProcessStartedEventArgs e)
    {
            this.ProcessStarted((ISubscriber<T>)e.CurrentSubscription);
    }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Want to swallow all exceptions and allow code to continuing to execute")]
        private void OnTimedEvent(object sender, ElapsedEventArgs e)
        {
            try
            {
                Trace.WriteLine("About to check if process is still running");
                Counter.Increment(7);
                if (!processRunning)
                {
                    var sw = Stopwatch.StartNew();
                    Counter.Increment(8);
                    Trace.WriteLine("Starting new process");
                    processRunning = true;
                    this.ProcessBatch();
                    CheckProcessingStatus();
                    processRunning = false;
                    Trace.WriteLine(string.Format(CultureInfo.InvariantCulture, "Batch process ran for {0:#,#} ms", sw.ElapsedMilliseconds));
                }
                else
    {
                    Trace.WriteLine("Yes it is");
                }
            }
            catch (Exception ex)
        {
                Trace.WriteLine(ex);
            }
        }

        private bool IsReady()
        {
            if (this.queueProvider == null) return false;
            if (this.subscriberInfos.Count == 0) return false; // will not work with no subscribers
            //// if(this.MessageIds == null) return false;
            if (this.timer == null) return false;
            //// if (!GetSubScribersCalled) return false; called in timer
            return true;
        }

        private bool RemoveFromQueue(Subscribers<T> currentSubscribers)
        {
            // need to lock the removal from queue with the system wide collection that is tracking its status
            // if it reoves any subscription it will return true and attempt to remove from the queue
            lock (queueLock)
            {
                this.queueProvider.RemoveFromQueue(currentSubscribers[0].MessageId);
                activeSubscriptions.RemoveIfExists(currentSubscribers);
    }

            return true;
        }
    }
}
