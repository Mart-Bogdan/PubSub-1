namespace Phantom.PubSub
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Globalization;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;
    using System.Timers;
    using System.Transactions;
    using Phantom.PubSub;

    /// <summary>
    /// PublishSubscribeChannel will accepts new messages puts them on a queue and fire calls to all subscribers
    /// </summary>
    /// <typeparam name="T">The Type that you wish tp publish each type requires its own implementation</typeparam>
    public class PublishSubscribeChannel<T> : IPublishSubscribeChannel<T>, IDisposable
    {
        private static object queueLock = new object();
        
        //private static ActiveSubscriptionsDictionary<T> activeSubscriptions;
        
        private IQueueProvider<T> queueProvider;

        private Dictionary<string, Tuple<string, Type, TimeSpan>> subscriberInfos = new Dictionary<string, Tuple<string, Type, TimeSpan>>();
        
        public PublishSubscribeChannel()
        {
        }

        public PublishSubscribeChannel(IQueueProvider<T> queueProvider)
        {
            this.queueProvider = queueProvider;
            //activeSubscriptions = new ActiveSubscriptionsDictionary<T>();
        }

        ~PublishSubscribeChannel()
        {
            // Finalizer calls Dispose(false)
            this.Dispose(false);
            }

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Publishes a message first by placing on a durable Queue, then passing the message to a new thread for processing.
        /// Returns as soon as the message is succesfully on the Queue.
        /// This component does not read the message from the Que to start processing. It takes the same message that is added to the Queue and starts processing
        /// as soon as it is guaranteed to be on the queue.
        /// </summary>
        /// <param name="message">The message of the type specified to process</param>
        public void PublishMessage(T message)
        {
            if (!BatchProcessor<T>.IsConfigured)
            {
                BatchProcessor<T>.ConfigureWithPubSubChannel(this);
            }

            if (this.subscriberInfos.Count == 0)
            {
                foreach (var item in AutoConfig<T>.SubscriberInfos)
                {
                    this.subscriberInfos.Add(item.Item1, new Tuple<string, Type, TimeSpan>(item.Item1, item.Item2, item.Item3));
                }
                
            }

            List<ISubscriberMetadata> metadatalist = new List<ISubscriberMetadata>();

            foreach (var item in this.subscriberInfos)
            {
                var subscribermetadata = new SubscriberMetadata()
                {
                    Name = item.Key, 
                    TimeToExpire = item.Value.Item3,
                    StartTime = DateTime.Now,
                };
                metadatalist.Add(subscribermetadata);
            }

            var messageForQueue = new MessagePacket<T>(message, metadatalist);

            string result = this.queueProvider.PutMessageInTransaction(messageForQueue);
            Task.Factory.StartNew(() => this.HandleMessageForFirstTime(messageForQueue, result));
        }

        /// <summary>
        /// Batch processing alternative, this is used as part of the clean up process for Messages that expire prior to being handled. 
        /// </summary>
        public void ProcessBatch()
        {
            this.queueProvider.ProcessQueueAsBatch(this.HandleMessageForBatchProcessing);
        }

        /// <summary>
        /// This method receives a single message and processes all of the subscribers for each individual message. The subscribers are processed in parallel
        /// to ensure that one long running process will not impact the others.
        /// When all subscribers have indicate they have completed a flag is set to indicate that this message has completed publishing, and it is removed 
        /// from the Queue
        /// This method uses the Parallel.ForEach method, so Visual Studio parallel debugging can be used.
        /// </summary>
        /// <param name="messagePacket">THe message being sent inside of the messagepacket wrapper</param>
        /// <param name="messageId">ID of message generated by the queuein mechanism</param>
        /// <returns>True on success</returns>
        public bool HandleMessageForFirstTime(MessagePacket<T> messagePacket, string messageId)
        {
            if (messagePacket == null) throw new ArgumentNullException("messagePacket");
            if (string.IsNullOrEmpty(messageId)) throw new ArgumentNullException("messagePacket");

            var subscribersForThisMessage = this.GetSubscriptions();
            
            var allSubscribersTask = Task.Run(async () =>
            {
                foreach (var subscriber in subscribersForThisMessage)
                {
                    string newSubscriptionId = " SubScriber: " + subscriber.Name + ":: MessageID: " + messageId + "::";
                    subscriber.Id = newSubscriptionId;
                    subscriber.MessageId = messageId;
                    var cancellationToken = new CancellationTokenSource(subscriber.TimeToExpire).Token;

                    //cancellationToken.Register(() =>
                    //{
                    //    Trace.WriteLine("Subscriber being cancelled " + subscriber.Id + subscriber.Name);
                    //    Trace.WriteLine("Subscriber being cancelled m(s) " + DateTime.Now.Ticks);
                    //    //Trace.WriteLine("Subscriber being cancelled " + cancellationToken.);
                    //    //subscriber.Abort();
                    //});
                    await subscriber.RunAsync((T)messagePacket.Body, cancellationToken)
                    .ContinueWith(anticedant =>
                    {
                        switch (anticedant.Status)
                        {
                            case TaskStatus.RanToCompletion:
                                Counter.Increment(14);
                                break;
                            case TaskStatus.Faulted:
                                var newMessagId = this.queueProvider.PutMessageInTransaction(CreateSingleSubscriberMessagePacket(subscriber, messagePacket));
                                Counter.Increment(13);
                                subscriber.Abort();
                                //Trace.WriteLine("Request failed: " + newSubscriptionId + " newMessagId" + newMessagId + " " + anticedant.Exception.InnerException.ToString());
                                break;
                            case TaskStatus.Canceled:
                                this.queueProvider.PutMessageInTransaction(CreateSingleSubscriberMessagePacket(subscriber, messagePacket));
                                subscriber.Abort();
                                Counter.Increment(12);
                                Trace.WriteLine("This task timed out : " + subscriber.Name + " The timeout timespan was: " + subscriber.TimeToExpire.TotalMilliseconds + " ms");
                                //Trace.WriteLine("Request was canceledxxx");
                                break;
                        }
                    });
                }
            });
            this.queueProvider.RemoveFromQueue(messageId);

            //.ContinueWith(anticedant =>
            //{
            //    this.queueProvider.RemoveFromQueue(messageId);
            //});
            return true;
        }

        private MessagePacket<T> CreateSingleSubscriberMessagePacket(ISubscriber<T> subscriber, MessagePacket<T> messagePacket)
        {
            Counter.Increment(19);
            //Trace.WriteLine("In CreateSingleSubscriberMessagePacket ");

            List<ISubscriberMetadata> metadatalist = new List<ISubscriberMetadata>();
            var subscribermetadata = new SubscriberMetadata()
            {
                //need to add abort count and think thru appropriate start time
                Name = subscriber.GetType().Name,
                TimeToExpire = subscriber.TimeToExpire,
                StartTime = subscriber.StartTime,
                RetryCount = ++subscriber.AbortCount,
                FailedOrTimedOut = true,
                FailedOrTimedOutTime = subscriber.AbortedTime
            };
            metadatalist.Add(subscribermetadata);
            return new MessagePacket<T>((T)messagePacket.Body, metadatalist);
        }

        public bool HandleMessageForBatchProcessing(MessagePacket<T> messagePacket, string messageId)
        {
            //Trace.WriteLine("In HandleMessageForBatchProcessing, messageId: " + messageId);
            if (messagePacket == null) throw new ArgumentNullException("messagePacket");
            if (string.IsNullOrEmpty(messageId)) throw new ArgumentNullException("messagePacket");
            
            if (messagePacket.SubscriberMetadataList.Count == 1)
            {
                //Trace.WriteLine("In HandleMessageForBatchProcessing, Subscriber Count 1 so handling message: " + messageId);
                return HandleSingleSubscriberforMessage(messagePacket, messageId);
            }
            //Trace.WriteLine("In HandleMessageForBatchProcessing, Subscriber Count NOT 1 so doing nothing message: " + messageId);

            //we may see this called but it should be a timing issue
            //expired subscriptions get a new message in the que and the original message removed

            foreach (var item in messagePacket.SubscriberMetadataList)
            {
                //string subscriptionId = " SubScriber: " + item.Name + ":: MessageID: " + messageId + "::";
                //Trace.WriteLine("About to check if I can process: " + subscriptionId);

                //ISubscriber<T> newSubscription = null;

                if (item.CanProcess())
                {
                    HandleMessageForFirstTime(messagePacket, messageId);
                    break;
                }
            }
            return true;
        }
            //        Trace.WriteLine("Processing: " + subscriptionId);
            //        var subscriberInfo = this.subscriberInfos.FirstOrDefault(si => si.Key == item.Name);
            //        newSubscription = (ISubscriber<T>)Activator.CreateInstance(subscriberInfo.Value.Item2);
            //        newSubscription.Name = subscriberInfo.Value.Item1;
            //        newSubscription.TimeToExpire = subscriberInfo.Value.Item3;

            //        var cancellationToken = new CancellationTokenSource(newSubscription.TimeToExpire).Token;
            //        var task = Task.Run(async () =>
            //        {
            //            await newSubscription.RunAsync((T)messagePacket.Body, cancellationToken);
            //            return true;
            //        })
            //        .ContinueWith(anticedant =>
            //        {
            //            switch (anticedant.Status)
            //            {
            //                case TaskStatus.RanToCompletion:
            //                    Counter.Increment(16);
            //                    //Trace.WriteLine("Request succeeded: {0}" +  anticedant.Result.ToString());
            //                    break;
            //                case TaskStatus.Faulted:
            //                    this.queueProvider.PutMessageInTransaction(CreateSingleSubscriberMessagePacket(newSubscription, messagePacket));
            //                    Counter.Increment(17);
            //                    newSubscription.Abort();
            //                    //Trace.WriteLine("Request failed: {0}" + anticedant.Exception.InnerException.ToString());
            //                    break;
            //                case TaskStatus.Canceled:
            //                    this.queueProvider.PutMessageInTransaction(CreateSingleSubscriberMessagePacket(newSubscription, messagePacket));
            //                    newSubscription.Abort();
            //                    Counter.Increment(18);
            //                    //Trace.WriteLine("This task timed out : " + subscriber.Name + " The timeout timespan was: " + subscriber.TimeToExpire.TotalMilliseconds + " ms");
            //                    Trace.WriteLine("Request was canceled");
            //                    break;
            //            }
            //        });
        //        //}
        //    }   
        //    return true;
        //}

        private bool HandleSingleSubscriberforMessage(MessagePacket<T> messagePacket, string messageId)
        {
            var metaData = messagePacket.SubscriberMetadataList[0];
            string subscriptionId = " SubScriber: " + metaData.Name + ":: MessageID: " + messageId + "::";
            //Trace.WriteLine("About to check if I can process: " + subscriptionId);

            ISubscriber<T> newSubscription = null;

            if (metaData.CanProcess())
            {

                //Trace.WriteLine("Processing: " + subscriptionId);
                var subscriberInfo = this.subscriberInfos.FirstOrDefault(si => si.Key == metaData.Name);
                newSubscription = (ISubscriber<T>)Activator.CreateInstance(subscriberInfo.Value.Item2);
                newSubscription.Name = subscriberInfo.Value.Item1;
                newSubscription.TimeToExpire = subscriberInfo.Value.Item3;

                var cancellationToken = new CancellationTokenSource(newSubscription.TimeToExpire).Token;
                var task = Task.Run(async () =>
                {
                    await newSubscription.RunAsync((T)messagePacket.Body, cancellationToken);
                    return true;
                })
                .ContinueWith(anticedant =>
                {
                    switch (anticedant.Status)
                    {
                        case TaskStatus.RanToCompletion:
                            Counter.Increment(16);
                            this.queueProvider.RemoveFromQueue(messageId);
                            //Trace.WriteLine("Request succeeded: {0}" +  anticedant.Result.ToString());
                            break;
                        case TaskStatus.Faulted:
                            try
                            {
                                this.queueProvider.PutMessageInTransaction(CreateSingleSubscriberMessagePacket(newSubscription, messagePacket));
                                Counter.Increment(20);
                            }
                            catch
                            {
                                break;
                            }
                            this.queueProvider.RemoveFromQueue(messageId);
                            break;
                        case TaskStatus.Canceled:
                            try
                            {
                                this.queueProvider.PutMessageInTransaction(CreateSingleSubscriberMessagePacket(newSubscription, messagePacket));
                                Counter.Increment(18);
                                Trace.WriteLine("Request was canceled");
                            }
                            catch
                            {
                                break;
                            }                          
                            //Trace.WriteLine("This task timed out : " + subscriber.Name + " The timeout timespan was: " + subscriber.TimeToExpire.TotalMilliseconds + " ms")                          
                            this.queueProvider.RemoveFromQueue(messageId);
                            break;
                    }
                });
            }
            return true;
        }

        public Subscribers<T> GetSubscriptions()
        {
            if (this.subscriberInfos == null || this.subscriberInfos.Count == 0)
            {
                throw new InvalidOperationException("There are no subscribers set up for this channel");
            }

            var subscribers = new Subscribers<T>();
            foreach (var item in this.subscriberInfos)
            {
                ISubscriber<T> subscriber = (ISubscriber<T>)Activator.CreateInstance(item.Value.Item2);
                subscriber.Name = item.Value.Item1;
                subscriber.TimeToExpire = item.Value.Item3;
                subscriber.SubscribersForThisMessage = subscribers;
                subscribers.Add(subscriber);   
            }

            return subscribers;
        }

        /// <summary>
        /// This method is provide for the inheriting member to override and allow some pre-processing in the Process Started event
        /// </summary>
        /// <param name="currentSubscription">The currently being processed subscription</param>
        public virtual void ProcessStarted(ISubscriber<T> currentSubscription) 
        {
        }

        /// <summary>
        /// Handles all post processing. Sets the status of the Subscriber to complete. Sets the status of the subsciption to complete.
        /// Checks if all of the other subscribers for this specific message have both started and completed, if they have then the function will
        /// call the queue provider to remove the message from the queue.
        /// </summary>
        /// <param name="currentSubscriber">the subscriber currently being processed</param>
        public void ProcessCompleted(ISubscriber<T> currentSubscriber)
        {
            if (currentSubscriber == null) throw new ArgumentNullException("currentSubscriber");

            ////Trace.WriteLine("Process Completed " + currentSubscriber.Id);

            currentSubscriber.FinishedProcessing = true;

            if (currentSubscriber.SubscribersForThisMessage.IfAllSubscribersCompletedLockAndRemove(this.RemoveFromQueue))
            {
            }
        }

        public ISubscriberInfo<T> AddSubscriberType(Type type)
        {
            return new SubscriberInfo<T>(type, this);
        }

        public IPublishSubscribeChannel<T> AddSubscriberInfo(Tuple<string, Type, TimeSpan> tuple)
        {
            if (tuple == null) throw new ArgumentNullException("tuple");

            this.subscriberInfos.Add(tuple.Item1, tuple);
            return this;
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
            }
        }

        private static bool HasExpired(ISubscriberMetadata subscriberMetaData)
        {
            var nextstart = subscriberMetaData.StartTime + subscriberMetaData.TimeToExpire;
            if (DateTime.Compare(DateTime.Now, nextstart) > 0)
            {
                return true;
            }
            return false;
        }

        //private static void CheckProcessingStatus()
        //{
        //    // look for subscribers that have not completed by ther expirery time
        //    activeSubscriptions.ExpireOldSubscriptions();
        //}

        private void Subscriber_OnProcessCompletedEvent(object sender, ProcessCompletedEventArgs e)
        {
            this.ProcessCompleted(e.CurrentSubscription as ISubscriber<T>);
        }

        private void Subscriber_OnProcessStartedEvent(object sender, ProcessStartedEventArgs e)
        {
            this.ProcessStarted((ISubscriber<T>)e.CurrentSubscription);
        }

      

        private bool IsReady()
        {
            if (this.queueProvider == null) return false;
            if (this.subscriberInfos.Count == 0) return false; // will not work with no subscribers
            //// if(this.MessageIds == null) return false;
            //// if (!GetSubScribersCalled) return false; called in timer
            return true;
        }

        private bool RemoveFromQueue(Subscribers<T> currentSubscribers)
        {
            // need to lock the removal from queue with the system wide collection that is tracking its status
            // if it reoves any subscription it will return true and attempt to remove from the queue
            lock (queueLock)
            {
                this.queueProvider.RemoveFromQueue(currentSubscribers[0].MessageId);
               // activeSubscriptions.RemoveIfExists(currentSubscribers);
            }

            return true;
        }
    }
}
