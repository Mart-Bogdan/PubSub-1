namespace Phantom.PubSub
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using Microsoft.Practices.EnterpriseLibrary.Logging;
    using Phantom.PubSub;

    /// <summary>
    /// The subscriber is the class to inherit from to create your custom subscriptions to the message.
    /// Overwrite the Process method with the custom method you wish. The PubSub Channel will contiue to call 
    /// the Run command until the subscription acknowledges that it has finnished processing.
    /// </summary>
    /// <typeparam name="T">Create a subscriber for your specific type of Message</typeparam>
    public abstract  class Subscriber<T> : ISubscriber<T>
    {
        #region ISubscriber<T> Members
        
        /// <summary>
        /// Method to override to provide custom processing. This method should not be called directly in your code. I should proably
        /// figure out ow to make it safer from poor coding. 
        /// </summary>
        /// <param name="message">Message of the type specified</param>
        /// <param name="messageId">Message Identifier typically unique and generated by the queue provider that is being used</param>
        /// <param name="subscriptionId">Id of the subscription compond key of unique messageId and Subscritption Name. THis field Identifies a 
        /// specific message and subscriber combination</param>
        /// <param name="subScriptionStatus">Current status of subscription - started completed etc. this is a object that is also contained in the 
        /// trackIfStarted parameter. It provides access in the method to this specific status</param>
        /// <param name="trackIfStarted">List of subscribers that carry a flag to indicate that it has started or not</param>
        /// <returns>True process succesfully completed</returns>
        public abstract bool Process(T message, string messageId, string subscriptionId, IMessageStatus<T> subScriptionStatus, List<IMessageStatus<T>> trackIfStarted);

        /// <summary>
        /// Private method called by Run command, prior to Process being called. Completes Preprocessing tasks of
        /// setting up the object and raising the OnProcessStarted event
        /// </summary>
        /// <param name="message">Message of the type specified</param>
        /// <param name="messageId">Message Identifier typically unique and generated by the queue provider that is being used</param>
        /// <param name="subscriptionId">Id of the subscription compond key of unique messageId and Subscritption Name. THis field Identifies a 
        /// specific message and subscriber combination</param>
        /// <param name="subScriptionStatus">Current status of subscription - started completed etc. this is a object that is also contained in the 
        /// trackIfStarted parameter. It provides access in the method to this specific status</param>
        /// <param name="trackIfStarted">List of subscribers that carry a flag to indicate that it has started or not</param>
        /// <returns>True process succesfully completed</returns>
        private bool PreProcess(T message, string MessageId, string SubscriptionId, IMessageStatus<T> SubScriptionStatus, List<IMessageStatus<T>> TrackIfStarted)
        {
            this.MessageStatusTracker.StartedProcessing = true; 
            this.StartTime = DateTime.Now;
            this.Id = SubscriptionId;
            this.Aborted = false;
            OnProcessStartedEvent(this, new ProcessStartedEventArgs(MessageId, SubscriptionId, this, SubScriptionStatus, TrackIfStarted));         
            return true;
        }
        
        /// <summary>
        /// Call this method to execute your custom process 
        /// <param name="message">Message of the type specified</param>
        /// <param name="messageId">Message Identifier typically unique and generated by the queue provider that is being used</param>
        /// <param name="subscriptionId">Id of the subscription compond key of unique messageId and Subscritption Name. THis field Identifies a 
        /// specific message and subscriber combination</param>
        /// <param name="subScriptionStatus">Current status of subscription - started completed etc. this is a object that is also contained in the 
        /// trackIfStarted parameter. It provides access in the method to this specific status</param>
        /// <param name="trackIfStarted">List of subscribers that carry a flag to indicate that it has started or not</param>
        /// <returns>True process succesfully completed</returns>
        public bool Run(T message, string MessageId, string SubscriptionId, IMessageStatus<T> SubScriptionStatus, List<IMessageStatus<T>> TrackIfStarted)
        {
            if(PreProcess(message, MessageId, SubscriptionId, SubScriptionStatus, TrackIfStarted))
            {// do some thing on false 
            }   
            
            if(this.Process(message, MessageId, SubscriptionId, SubScriptionStatus, TrackIfStarted))
            {// do some thing on false 
            }
            
            return this.PostProcess(message, MessageId, SubscriptionId, SubScriptionStatus, TrackIfStarted);
        }

        /// <summary>
        /// Private method called by Run command, runs after the method Process has being called. Completes Post processing tasks of
        /// setting up the object and raising the OnProcessStarted event
        /// </summary>
        /// <param name="message">Message of the type specified</param>
        /// <param name="messageId">Message Identifier typically unique and generated by the queue provider that is being used</param>
        /// <param name="subscriptionId">Id of the subscription compond key of unique messageId and Subscritption Name. THis field Identifies a 
        /// specific message and subscriber combination</param>
        /// <param name="subScriptionStatus">Current status of subscription - started completed etc. this is a object that is also contained in the 
        /// trackIfStarted parameter. It provides access in the method to this specific status</param>
        /// <param name="trackIfStarted">List of subscribers that carry a flag to indicate that it has started or not</param>
        /// <returns>True process succesfully completed</returns>
        private bool PostProcess(T message, string MessageId, string SubscriptionId, IMessageStatus<T> SubScriptionStatus, List<IMessageStatus<T>> TrackIfStarted)
        {
            this.MessageStatusTracker.FinishedProcessing = true;
            OnProcessCompletedEvent(this, new ProcessCompletededEventArgs(MessageId, SubscriptionId, this, SubScriptionStatus, TrackIfStarted));
            return true;
        }

        public virtual bool Process(T input)
        {
            System.Diagnostics.Debug.WriteLine("Writing stuff: {0}", "in Process");
            return true;
        }
       
        public string Name { get; set; }
        
        public string Id { get; set; }
        
        public string MessageId { get; set; }
        
        public DateTime AbortedTime { get; set; }
        
        private int AbortCount = 0;

        public bool Abort()
        {
            this.Aborted = true;
            this.AbortedTime = DateTime.Now;
            this.AbortCount = ++this.AbortCount;
            this.MessageStatusTracker.StartedProcessing = false;
            this.MessageStatusTracker.FinishedProcessing = false;
            return true;
        }

        public virtual event OnProcessStartedEvent OnProcessStartedEvent;
        
        public virtual event OnProcessCompletedEvent OnProcessCompletedEvent;
 
        public TimeSpan TimeToExpire { get; set; }
        
        public DateTime StartTime { get; set; }
       
        private bool aborted;
        
        public bool Aborted
        {
            get
            {
                return aborted;
            }

            set
            {
                aborted = value;
                this.AbortedTime = DateTime.Now;
                ////if (OnSubscriptionStatusUpdatedEvent != null)
                ////{
                ////    OnSubscriptionStatusUpdatedEvent(this, new SubscriptionStatusUpdateEventArgs(SubscriptionStatusChange.Aborted, this.MessageStatusTracker.StartedProcessing, this.MessageStatusTracker.FinishedProcessing, value, this.AbortedTime));
                ////}
            }
        }
        
        public DateTime ExpireTime
        {
            get
            {
                ////pretty certain changes mean that the start time is always reset to when it actually starts so this code iss just wrong
                ////if (AbortCount > 0)
                ////{
                ////    return AbortedTime + TimeToExpire; 
                ////}
                ////else 
                ////{
                    return StartTime + TimeToExpire;
                ////}
            }

            set
            {
                throw new NotImplementedException();
            }
        }

        public bool CanProcess()
        {
            ////LogEntry log2 = new LogEntry();
            ////log2.Message = ("this.FinishedProcessing:" + this.FinishedProcessing + ":: this.StartedProcessing: " + this.StartedProcessing + "this.Aborted" + this.Aborted + "MessageID: " + this.MessageId);
            ////Logger.Write(log2);

            ////if (this.FinishedProcessing) return false; //it could have finished processing but not yet be removed from list of active subscriptions
            ////if (this.StartedProcessing && !this.FinishedProcessing) return false;// in process, do not re start clean up process will handle aborting
            ////if (this.StartedProcessing && this.FinishedProcessing) return false;// processing has started and finished but it has not yet been removed from the collection
            ////if its started and not finished or aborted
            ////if(!this.StartedProcessing && !this.Aborted) return true;// 
            ////if (!this.StartedProcessing && this.Aborted)

            //trying new rules if aborted then check for restart on restart set aborted back to false
            if (this.Aborted)
            {             
                ////log2.Message = ("Has  not started in Aborted state::this.AbortedTime:" + this.AbortedTime + ":: Abortcount: " + this.AbortCount);
                ////Logger.Write(log2);

                //see if it is time for a restart.
                double time = Math.Pow(2, AbortCount);
                TimeSpan ts = new TimeSpan(0,Convert.ToInt32(time),0);
                
                DateTime nextstart = this.AbortedTime + ts;

                ////log2.Message = ("nextstart:" + nextstart + ":: DateTime.Now: " + DateTime.Now);
                ////Logger.Write(log2);

                if (DateTime.Compare(DateTime.Now, nextstart) < 0)
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }

            return false; // all else fails return false to snsure it is ot restarted unnessarily
            // it can always get picked up in the next loop
        }

        public IMessageStatus<T> MessageStatusTracker { get; set; }

        #endregion
    }
}
